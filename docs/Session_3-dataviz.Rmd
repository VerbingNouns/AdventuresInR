---
title: "Adventures in R Session 3: Dataviz"
output:
  html_document:
    toc: yes
    toc_depth: 3
    df_print: paged
    number_sections: true
    toc_float:
      collapsed: false
---

[Return to main page](https://verbingnouns.github.io/AdventuresInR/)

```{r setup}
## Packages required for this lesson:
#install.packages(c("tidyverse","palmerpenguins"))
library(tidyverse) # Rstudio should prompt you if a package is required to run a notebook but isn't installed.
library(palmerpenguins)
```

# Visualisation

## Why dataviz?

If you don't know the shape of your data, you might not draw appropriate conclusions about the statistical tests you perform.

Check out the [Datasaurus Dozen](https://www.autodeskresearch.com/publications/samestats), which all have the same x/y means and standard deviations, sometimes called the Simpson Paradox.

![](../images/datasaurus.gif)

Dataviz is also engaging, communicative, creative, efficient, and fun.

## Base R plots

There are some ways to create plots quickly, and it's good to know a little about that before we get too far.

```{r}
plot(penguins$bill_length_mm, penguins$bill_depth_mm)
```

We will talk more about what to do with these plots later, but I want to show you a Quantile-Quantile plot (QQ plot) output so you can see how easy it is to make even before we discuss why you'd want to make it.

```{r}
qqplot(penguins$bill_length_mm, penguins$bill_depth_mm)

qqnorm(penguins$bill_length_mm)
qqline(penguins$bill_length_mm)
```


# Visual grammar

In the `tidyverse`, the package for making elegant plots is called `ggplot2`. It works a lot like how pipes work by building up graphics in layers, but since it was originally designed as a separate package, it uses `+` instead of `%>%`. This might seem to be a bit of a faff at first, but it ends up being powerful (and easy once you know how the components work).

To begin, we need to specify what data we're using.

```{r blank plot}
# this will print a blank plot
penguins %>% 
  ggplot() + 
  theme_bw() + # this line makes it easy to print and more accessible for visual disabilities
  NULL # this line allows us to end each preceding content line with a + regardless of order or comments
```

This is the background of the plot -- a check to see that `penguins` is something that can be plotted from.

To start adding things to the plot, we need to specify what we want the plot to extract from `penguins`. That means we have to tell it what the axes are. Make the x-axis `bill_length_mm` and the y-axis `bill_depth_mm`.

```{r empty grid}
# this will print a *mostly* blank plot...
penguins %>% 
  ggplot(aes(x = bill_length_mm,
             y = bill_depth_mm)) +
  theme_bw() +
  NULL
```


Now the plot knows a bit more about what we're asking, but not enough to show up the data. This is how `ggplot()` differs from just `plot()`. By itself, `plot()` infers *how* we want to display our data. This is great when it's correct and not great when it's wrong (which it often is, without additional specifications). In contrast, `ggplot()` requires the specifications from the start, but they're integrated more smoothly.

Now let's tell it what kind of plot to make. This is called the plot's "geometry", abbreviated "geom".

```{r simple_scatterplot}
# make a scatter plot
penguins %>% 
  ggplot(aes(x = bill_length_mm,
             y = bill_depth_mm)) +
  theme_bw() +
  geom_point() +
  NULL
```

You can get rid of the message at the top (which we don't care about) by adding `, warning = FALSE` after the code chunk identifier:

`{r, warning = FALSE}`

You can do a lot of other neat stuff here, but you'll have to look that up on your own time.

## Lines of best fit

Our eyes are not designed to find *subtle* patterns in data, and our minds will often "see" patterns and differences where none exist. Therefore, we should always confirm what we see with statistics. One way to do that is to draw a **line of best fit**. This works best with continuous data (as below), but it can also work with categorical and binomial data (in the appendix).

```{r add_slope, warning=FALSE}
# add a line of best fit
penguins %>% 
  ggplot(aes(x = bill_length_mm,
             y = bill_depth_mm)) +
  theme_bw() +
  geom_point() +
  geom_smooth(method = "lm", formula = "y ~ x") + # line of best fit based on the lm() method
  NULL
```

This line suggests that as bill length gets longer, bill depth gets smaller, overall. However, there is clearly a lot of variance in this data! Perhaps we could add another variable to the point plot to figure out where that "noise" is coming from.


```{r colour_as_a_dimension, warning=FALSE}
# fill in plot with colour contigent on species
penguins %>% 
  ggplot(aes(x = bill_length_mm,
             y = bill_depth_mm,
             colour = species)) + # add colour to the base aesthetics
  theme_bw() +
  geom_point() +
  NULL
```

This gives a very different picture of the relationship between bill length and bill depth! Let's re-add the smooths to see how those lines of best fit are oriented.

```{r slope_by_species, warning=FALSE}
penguins %>% 
  ggplot(aes(x = bill_length_mm,
             y = bill_depth_mm,
             colour = species)) + # add a line to plot colour contingent on a mapping
  theme_bw() +
  geom_point() +
  geom_smooth(method = "lm",
              formula = "y ~ x") +
  NULL
```

Notice how the colour propagates to both the points and to the smooths. This is because any aesthetics specified in the `ggplot()` function is "inherited" by the rest of the geometries. If you don't want something to be inherited, you can specify it in only the geometry you want it to be part of.

That said, both "pictures" of the data are correct: 

```{r all_slopes, warning=FALSE, message=FALSE}
penguins %>% 
  ggplot(aes(x = bill_length_mm,
             y = bill_depth_mm)) + 
  theme_bw() +
  geom_point(aes(colour = species)) + # colour by species for points only
  geom_smooth(colour = "black", 
              method = "lm",
              formula = "y ~ x") + # line of best fit regardless of species
  geom_smooth(aes(colour = species), 
              method = "lm",
              formula = "y ~ x") + # line of best fit contingent on species
  NULL
```

These lines of best fit give us insight into what our statistical models will be telling us, when we run them.

## Types of plots

Let's take a look at what's needed to make a histogram or density plot.

```{r, warning = FALSE}
ggplot(penguins, 
       aes(x = bill_length_mm,
           fill = species)) +
  theme_bw() +
  #geom_histogram(bins = 40) +
  #geom_density(alpha = .5) +
  NULL
```

Another common and useful type of plot is the box and whisker plot.

```{r, warning = FALSE}
ggplot(penguins, 
       aes(x = island,
           y = flipper_length_mm,
           fill = species)) +
  theme_bw() +
  geom_boxplot()
```

Bar plots are sometimes controversial, but they can also be very useful. They take slightly different arguments than other types of plots because of how the bar height is 'calculated'.

```{r, message=FALSE}
penguins %>% 
  filter(!is.na(flipper_length_mm)) %>% 
  group_by(species) %>% 
  summarise(flipper_length_mm_mean = mean(flipper_length_mm),
            flipper_length_mm_sd = sd(flipper_length_mm),
            flipper_length_mm_se = sd(flipper_length_mm)/sqrt(n())) %>% 
  ggplot(aes(x = species,
             y = flipper_length_mm_mean,
             fill = species)) +
  theme_bw() +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin = flipper_length_mm_mean - flipper_length_mm_sd, 
                    ymax = flipper_length_mm_mean + flipper_length_mm_sd),
                width = .2) +
  NULL
```

You may also want to explore fancier types of plots, or combine types we've already encountered. This is easy with `ggplot()`'s modular construction and visual grammar.

```{r, warning=FALSE}
ggplot(penguins, 
       aes(x = island,
           y = flipper_length_mm,
           fill = species)) +
  theme_bw() +
  geom_violin() +
  geom_boxplot(position = position_dodge(.9),
               alpha = .3) +
  geom_point(position = position_jitterdodge(.9),
             shape = 21,
             alpha = .75) +
  NULL
```


# Visual analysis

Statistics is (like) dangerous dark magic: if you know what you're doing, it means you've dedicated your life (soul) to it and have no time or capacity to do other things. If you don't know what you're doing, it can hurt you or people around you. If you're somewhere in the middle, it is best to go slow, hedge your bets, and use it judiciously.

Why is statistics something to be wary of?

- It's unintuitive. Human brains were not designed to understand proper statistics. 
- Human brains are too good at detecting patterns -- even if none exist.
- Human brains like attributing causality to things regardless of underlying mechanisms.
- Developing your expertise in your field or subfield of choice is a major undertaking, and statistics is an entirely independent area to develop expertise in as well.
- Be honest with yourself: how comfortable are you teaching yourself complex maths?
- Statistics is a tool for: 
    a. telling us what we already know
    b. telling us that our squishy human brains are only human (and wrong about what we think we know)

## Continuous data

Let's create our own toy dataset:

```{r}
set.seed(18) # 15 16
x = rnorm(50) # 50 random numbers from a normal distribution
y = 2 * x + 5 # for each x, multiply by 2 (slope) and add 5 (intercept)
```

Here is what this data look like. Too perfect, everything on a perfect line, even with randomness:

```{r}
tibble(x, y) %>% # create a table with two columns
  ggplot(aes(x=x, y=y)) + # establish the base of a plot
  geom_point() + # use points to plot the data
  theme_bw() + # use a nice theme
  geom_abline(intercept = 5, slope = 2, colour="red") # add a red line with the specified slope
```

Let's add more noise, like any complex system would have:

```{r}
e = rnorm(50) # random noise

# realistic model
y2 = 2 * x + 5 + e # slope = 2, intercept = 5, random noise ("error" or epsilon) = e

tbl1 <- tibble(x, y2) # combine into a dataset
```

How does the new noise change the data?

```{r}
tbl1 %>% # using this dataset
  ggplot(aes(x=x, y=y2)) + # create a base plot with x on the x-axis and y2 on the y axis
  geom_point() + # make it a scatter plot (points)
  theme_bw() + # make it pretty
  geom_abline(intercept = 5, slope = 2, colour="red") # add the red line to indicate intended slope and intercept
```

Is the red line still the best way to approximate this data?

```{r}
model1 <- lm(y2 ~ x) # calculate slope and intercept automatically
```

What are the calculated slope and intercept?

```{r}
coef(model1) # `coef` stands for coefficients
```

Plot the data with the intended shape of the data (red) and the calculated shape (green):

```{r}
tbl1 %>% # using the toy dataset
  ggplot(aes(x=x, y=y2)) + # establish the base of the plot
  geom_point() + # draw the data as points
  geom_vline(xintercept=0, colour="blue") + # add a vertical blue line at the "intercept" (y axis)
  geom_abline(intercept = 5, slope = 2, colour="red") + # add the intended shape of the data (red)
  geom_abline(intercept = coef(model1)[1], slope = coef(model1)[2], colour="green3") + # add the calculated shape (green)
  theme_bw() # make it pretty
```

How do the intended shape and calculated shape differ? Why?

We can actually extract this numbers (and more!) in a fancy looking output summary:

```{r}
summary(model1)
```

Moreover, there's actually a way to do this calculation *within* a plot:

```{r, message=FALSE}
tbl1 %>% 
  ggplot(aes(x=x, y=y2)) +
  geom_point() +
  geom_smooth(method="lm") + # here is where the calculation happens within the plot
  geom_vline(xintercept=0, colour="blue") +
  geom_abline(intercept = 5, slope = 2, colour="red") +
  geom_abline(intercept = coef(model1)[1], slope = coef(model1)[2], colour="green3") +
  theme_bw()
```

# Workshop activities

We have used `geom_point()` and `geom_smooth()` to plot data. R does most of the calculations for us, so we only need to specify certain dimensions of the plot and it does the rest. Now try getting R to plot a `geom_boxplot()` box and whisker plot with `species` on the x-axis and one of the numerical columns from `penguins` on the y-axis. Add the aesthetic `fill` to colour in the boxes. Try filling the boxes by `species`, but also try `island` or `year`, to see what happens.

```{r boxplot_activity, warning=FALSE}
# you can copy much of the code from the preceding chunks and edit it to change the geometries and aesthetic mappings.

```

